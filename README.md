# Ami Assistant 

![](https://i.imgur.com/L8GVUmX.png)

## Архитектура 

Приложение делится на 3 проекта: **фронт**(1), бэк/бизнес логика - **обработка команд**(2), **вспомагательные функции** - совокупность функций с помощью которых ассистент взаимодействует с ОС, интернетом и синтезатором речи(3)

## Логика работы ассистента

### Этап 1

![](https://i.imgur.com/nEcUJ52.png)

Главная задача дать пользователю платформу с помощью которой он может автоматизировать свои рутинные задачи. Действия выполняются если произнести/написать ассистенту одну фразу из произвольного кол-во фиксированных фраз(больше 1), например, "команда 1" или "какая будет температура".

Функциональность команд задает сам пользователь с помощью заранее определенного набора **action**'ов, у каждого **action** есть свой набор аргументов, аргументы могут быть **входными** и **выходными**(результат работы вспомагательной функции)

#### **Входные аргументы**

Входные разделяются на **обязательные** и **не обязательные(дефолтные)**. Если аргумент обязательный - то пользователь обязательно должен ввести значение аргумента; если аргумент необязательный - то используется значение из **переменной среды(Environment Variables)** если оно там есть, если там такого значение нет - используется дефолтое значение. Чтобы использовать дефолтное значение, просто в текстовом поле ничего не стоит писать.

***Environment Variables*** - объект хранящий все глобальные переменные, касающиеся пользователя и его предпочтений, пример: Имя, язык, валюта, локация(где живет), 12/24 формат времени.

Все аргументы **action**'ов принимают `string`, эти строки будут парсится конкретной реализаций аргумета(`IArgument`), к примеру если у нас аргумент *дата и время* - то будет возможность по разному записать входные значение(пример: *15.10.2002, вчера, в следующий четверг*), но в итоге после парсинга у нас будет одно представление даты и времени, которое в дальнейшем будет передваться вспомагательным функциям.

#### **Выходные аргументы**

Выходные аргументы **action**'ов используются как входные аргументы для других **action**'ов,  Для этого служит объект `CommandContext`, хранящий данные в виде ключ-значение. При выполнении какого-то **action**'a он записывает в объект все свои входные и выходные аргументы.

Чтобы использовть значения из `CommandContext` во входном аргументе необходимо написать `$(carg:[key])`, пример `$(carg:value)`.

```csharp
    public class CommandContext
    {
        // <название аргумента, значение аргумента>
        // Dictionary<string,string>
    }
    public interface IArgument
    {
        string Name { get; } // имя аргумента
        string FriendlyName {get; set; } // имя аргумента, исользуется для локализации 
        string Description { get; } // описание аргумента
        string[] ExamplesInput { get; } // примеры входящих значений, которые точно работают и прописаны в parseValue
        string ExampleOutput { get; } // вид выходного значения (value)
        string Value { get; } // значение аргумента

        bool? IsRequired { get; } // является ли аргумент обязательным, если да - то необходимо что бы пользователь ввел значение
                                 // если нет - используется дефолтное значение, либо переменная среды

        bool parseValue(string inputValue); // true - если обработка прошла успешно
    }

    public interface IAction
    {
        string Name { get; }
        string Description { get; }
        IArgument[] InputArguments { get; }
        IArgument[] OutputArguments { get; }

        void execute(ref CommandContext context);
    }

    public class Command
    {
        public List<string> Commands { get; } = new List<string>();
        public List<IAction> Actions { get; } = new List<IAction>();
        public CommandContext Context { get; } = new CommandContext();

        public string execute()
        {
            return null;
        }
    }
```

### Этап 2

![](https://i.imgur.com/sVLdVua.png)

**2 этап** заключается в том чтобы дать возможность пользователя создавать динамические команды, в которых аргументы буду произнесены пользователем вместе с командой, при это расположение аргументов должны быть обозначены пользователем. Пример, *курс **биткоина** в **гривнах***, *курс **эфириума** в **долларах***.

### Этап 3

![](https://i.imgur.com/m5dO6MH.png)

3 этап заключается в создании алгоритма, который будет сам парсить фразу пользователя, которого нет в пользовательских командах. Алгоритм находит конкретные **action**, а так же их аргументы к этим действиям. `Null` - аргумент необязательный.

## Фронт (заметки)

- при наведении на **action** отображается список входных и выходных аргументов
- при наведении на аргумент отображается Description, ExamplesInput, ExampleOutput, обязательный ли он.
- если аргумент типа *время и дата* то показать диалог выбора времени и даты, если аргумент типа *файл* - показать `DialogOpen` или `DialogSave`, если тип *перечисление* - выпадающий список. 

## Actions

Action | Input arg | Output arg
---|---|---
Create| path_to_directory, filename | -
Execute | path_to_file | -
Rate | valuta1, valuta2 | value
Weather | location, date | value
Alarm | date | -
Speak | value | -
Return | value | -

## Стандартные комманды

- открой текстовый документ
- поставь будильник на 5 часов утра
- курс биткоина
- создай документ еа работчем столе
- какая погода на завтра
- расскажи шутку

## TODO in Future (тоесть никогда)

- использование в конструкторе action'ов циклов и условных операторов
- подаргументы (паттер Компановщик)